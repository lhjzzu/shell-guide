## 3.1 查找文本

> grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。

传统上，有三种程序，可以用来查找整个文件:

- grep:最早的文本匹配程序，使用基本正则表达式(Basic Regular Expression, BRE);
- egrep:扩展式grep(Extended grep)，使用扩展正则表达式(Extended Regular Expression, ERE),功能更加强大;
- fgrep:快速grep(Fast grep)，用于配置固定字符串，而非正则表达式.使用了优化的算法，更高效。(grep,egrep只能匹配一个正则表达式，而fgrep可以匹配多个字符串)
- 最终三个版本被整合为grep，通过不同选项加以控制。
  
### 3.1.1 简单的grep

grep最简单的用法就是使用固定字符串:

```
$ who | grep -F austen
$ who | grep austen
只要grep是匹配固定的字符串(非正则),默认的行为模式就是-F.
```
## 3.2 正则表达式


grep的语法:

```
                        grep
 语法:
 
    grep [options...] pattern-spec [files...]  
     
 用途:
 
    匹配一个或多个模式的文本行.时常作为管道的第一步，以便对匹配的数据作进一步的处理。
    
 主要选项:
     
    -E
       使用扩展正则表达式进行匹配(grep -E取代egrep)
    -F
       使用固定字符串进行匹配(grep -F取代fgrep)
    -e pat-list
       模式以减号开头时，grep会把它当做选项。而-e，可以指定其参数为模式--即便是它以减号开头。
    -f pat-file
       从pat-file文件读取模式作匹配
    -i 
       模式匹配时，忽略大小写差异
    -l 
       列出匹配模式的文件名称,而不是打印匹配的行
    -q
       静默的。如果模式匹配到，则grep会成功的离开，而不将匹配的行写入标准输出.
    -s 
       不显示错误信息。通常与-q并用
    -v
       显示不匹配模式的行.
       
    -a 不要忽略二进制数据。
    -A<显示列数> 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
    -b 在显示符合范本样式的那一行之外，并显示该行之前的内容。
    -c 计算符合范本样式的列数。
    -C<显示列数>或-<显示列数>  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
    -d<进行动作> 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
    -e<范本样式> 指定字符串作为查找文件内容的范本样式。
    -E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
    -f<范本文件> 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
    -F 将范本样式视为固定字符串的列表。
    -G 将范本样式视为普通的表示法来使用。
    -h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
    -H 在显示符合范本样式的那一列之前，标示该列的文件名称。
    -i 忽略字符大小写的差别。
    -l 列出文件内容符合指定的范本样式的文件名称。
    -L 列出文件内容不符合指定的范本样式的文件名称。
    -n 在显示符合范本样式的那一列之前，标示出该列的编号。
    -q 不显示任何信息。
    -R/-r 此参数的效果和指定“-d recurse”参数相同。
    -s 不显示错误信息。
    -v 反转查找。
    -w 只显示全字符合的列。
    -x 只显示全列符合的列。
    -y 此参数效果跟“-i”相同。
    -o 只输出文件中匹配到的部分。
     

行为模式
    读取命令行上指定的每个文件。发现匹配查找模式的行时，将它显示出来。当指明多个文件时，grep会在每一行前面加上文件名与一个冒号.默认使用BRE.    
                     
警告  
    你可以使用多个-e与-f选项，建立要查找的模式列表.                   

```

[grep的使用示例](http://man.linuxde.net/grep)
 
  ```
  1. 在文件中搜索符合模式的文本:grep "match_pattern" file1 file2 file3 ...
     
     $ grep -E '4\.1' 第4章:文本处理工具.md 第6章:变量，判断，重复动作.md
     
      第4章:文本处理工具.md:## 4.1 排序文本
      第4章:文本处理工具.md:### 4.1.1 行的排序
      第4章:文本处理工具.md:### 4.1.2 以字段排序
      第4章:文本处理工具.md:### 4.1.3 文本块排序
      第4章:文本处理工具.md:### 4.1.4 sort的效率
      第4章:文本处理工具.md:### 4.1.5 sort的稳定性
      第6章:变量，判断，重复动作.md:### 6.4.1 for循环
  
  2. 输出不符合模式的文本行:grep -v "match_pattern" file1
     
     $ grep -v '4\.1' 第4章:文本处理工具.md 第6章:变量，判断，重复动作.md
 
      第4章:文本处理工具.md:$ tail -n 25 -f /var/log/messages 
      第4章:文本处理工具.md:...
      第4章:文本处理工具.md:^C   
      第6章:变量，判断，重复动作.md:## 6.1 变量与算术
      第6章:变量，判断，重复动作.md:
      第6章:变量，判断，重复动作.md:> 同传统程序语言的变量一样，是用来保存某个值 
      ....
  3. 标记匹配颜色 --color=auto 选项：grep "match_pattern" file1 file2 --color=auto 
  
  4. 只输出文件中匹配到的部分: grep -o "match_pattern" file1 file2 
    
     $ grep -o '4\.1' 第4章:文本处理工具.md 第6章:变量，判断，重复动作.md
  
      第4章:文本处理工具.md:4.1
      第4章:文本处理工具.md:4.1
      第4章:文本处理工具.md:4.1
      第4章:文本处理工具.md:4.1
      第4章:文本处理工具.md:4.1
      第4章:文本处理工具.md:4.1
      第6章:变量，判断，重复动作.md:4.1
  

  5. 统计文件或者文本中包含匹配字符串的总行数: grep -c "match_pattern" file1 file2 
  
    $ grep -c '4\.1' 第4章:文本处理工具.md 第6章:变量，判断，重复动作.md
      
      第4章:文本处理工具.md:6
      第6章:变量，判断，重复动作.md:1
  
  6. 打印样式匹配所位于的字符或字节偏移: grep -b -o "match_pattern" file1 file2
     
   $ grep -b -o '4\.1' 第4章:文本处理工具.md 第6章:变量，判断，重复动作.md
   
     第4章:文本处理工具.md:0:4.1
     第4章:文本处理工具.md:92:4.1
     第4章:文本处理工具.md:163:4.1
     第4章:文本处理工具.md:2457:4.1
     第4章:文本处理工具.md:2513:4.1
     第4章:文本处理工具.md:2733:4.1
     第6章:变量，判断，重复动作.md:6738:4.1
     
 7. 输出匹配该模式的文件名: grep -l "match_pattern" file1 file2
   
   $ grep -l '4\.1' 第4章:文本处理工具.md 第6章:变量，判断，重复动作.md
   
     第4章:文本处理工具.md
     第6章:变量，判断，重复动作.md
     
 8. 忽略字符大小写: grep -i "match_pattern" file1 file2
   
   $ echo "hello world" | grep -i "HELLO" 忽略大小写，查找到hello
     hello
   
   $ echo "hello world" | grep "HELLO"   不忽略大小写，未查找到结果,没有任何输出。
 9. 匹配多个模式: grep -e pattern1 -e pattern2 file1 file2
 
  $ echo this is a text line | grep -e "is" -e "line" -o
    is
    is
    line
 10.grep静默输出: grep -q "match_pattern" file1 file2
 
 11. 显示匹配文本的后n行: grep  "match_pattern" file1 file2 -A n
     
  $ grep  '4\.1' 第4章:文本处理工具.md 第6章:变量，判断，重复动作.md -A 2
    
     第4章:文本处理工具.md:## 4.1 排序文本
     第4章:文本处理工具.md-
     第4章:文本处理工具.md-含有独立数据记录的文本文件，通常都可以拿来排序
     --
     ....
     --
     第6章:变量，判断，重复动作.md:### 6.4.1 for循环
     第6章:变量，判断，重复动作.md-
     第6章:变量，判断，重复动作.md-> 基本语法

 12. 显示匹配文本的前n行: grep  "match_pattern" file1 file2 -B n


     第4章:文本处理工具.md-当数据量n非常大时，冒泡排序，插入排序几乎会让数据增加到n2的平方那么大。而幸运的是，已经有很多有效率的算法，例如nlogn,n的分布排序等等
     第4章:文本处理工具.md-
     第4章:文本处理工具.md:### 4.1.5 sort的稳定性
     --
     ....
     --
     第6章:变量，判断，重复动作.md-## 6.4 循环
     第6章:变量，判断，重复动作.md-
     第6章:变量，判断，重复动作.md:### 6.4.1 for循环
 13. 同时显示匹配文本的前n行和后n行: grep  "match_pattern" file1 file2 -C n
 
 14. 在当前文件夹下递归搜索: grep "4\.1" . -r -n
   ./第3章:查找与替换.md:157:     第6章:变量，判断，重复动作.md:### 6.4.1 for循环
   ./第3章:查找与替换.md:166:     第4章:文本处理工具.md:### 4.1.5 sort的稳定性
   ./第3章:查找与替换.md:172:     第6章:变量，判断，重复动作.md:### 6.4.1 for循环
   ./第3章:查找与替换.md:457:#### 3.3.4.1 模式与操作
   ./第4章:文本处理工具.md:1:## 4.1 排序文本
   ./第4章:文本处理工具.md:5:### 4.1.1 行的排序
   ./第4章:文本处理工具.md:10:### 4.1.2 以字段排序
   ./第4章:文本处理工具.md:61:### 4.1.3 文本块排序
   ./第4章:文本处理工具.md:65:### 4.1.4 sort的效率
   ./第4章:文本处理工具.md:69:### 4.1.5 sort的稳定性
   ./第6章:变量，判断，重复动作.md:276:### 6.4.1 for循环
   ./第9章:awk的惊人表现.md:184:### 9.4.1 记录分隔字符
  
  15. 在grep搜索结果中包括或者排除指定文件:
    
    #只在目录中所有的.php和.html文件中递归搜索字符"main()"
     grep "main()" . -r --include *.{php,html}

    #在搜索结果中排除所有README文件
     grep "main()" . -r --exclude "README"

   #在搜索结果中排除filelist文件列表里的文件
     grep "main()" . -r --exclude-from filelist
    
  ```

### 3.2.1 什么是正则表达式?
* `POSIX BRE`与`ERE`的元字符(meta character)列表 (可移植操作系统接口 Portable Operating System Interface of UNIX，缩写为 POSIX ）

![](./image/3-1-1.png)
![](./image/3-1-2.png)

* 下表列举了一些例子

![](./image/3-2.png)


#### 3.2.1.1 POSIX方括号表达式

+ POSIX字符集
![](./image/3-3.png)


### 3.2.2 基本正则表达式

#### 3.2.2.1 匹配单个字符

以一般字符，以转义的meta字符，以`.`meta字符,或是用方括号表达式来进行匹配。

#### 3.2.2.2 向后引用

* BRE提供了一种向后引用的机制。使用`\digit`,来重复先前出现的`\(与\)`子表达式 
  + `digit`范围为`1~9`
  
```
例如

模式                               匹配成功
\(ab\)\(cd\)[def]*\2\1            abcdcdab, abcdeecdab等
\(why\).\1                         一行里出现两个why
\([[:alpha:]_][:alnum:]_*\) = \1; 简易C/C++赋值语句
\(["']\).*\1                      匹配以单引号或双引号括起来的数字
                                  (无须担心是单引号还是双引号先找到)
  
```

#### 3.2.2.3 单个表达式匹配多字符

+ `ab` 匹配`ab`
+ `..` 匹配任意两个字符
+ `[[:upper:]][[:lower:]]`匹配任意一个大写字符，后面接着任意一个小写字符
+ `*`匹配0个或多个前面的单个字符。ab*c表示匹配一个a,0个或多个b，以及一个c.
   - 例如: `ac`,`abc`,`abbc`,`abbbc`等
+ `\{n\}`前置表达式所得结果重现n次。
   - 例如: 重现5个a , `a\{5\}`
+ `\{n,\}`前置表达式所得结果重现至少n次。
+ `\{n,m\}`前置表达式所得结果重现n到m次。
  - 例如: 重现5到20个a , `a\{5,20\}`

#### 3.2.2.4 文本匹配锚点

* `^`和`$`叫做锚点(anchor),用于针对被匹配的字符串的开始或结尾进行匹配。
* `^`或`$`只在表达式开头或结尾具有特殊含义，在中间时表示其本身。

#### 3.2.2.5 BRE运算符优先级

BRE运算符优先级,由高到低

```
运算符             表示意义
[..] [==] [::]    用于字符排序的方括号符号
\metacharacter    转义的meta字符
[]                方括号表达式
\( \) \digit      子表达式与后向引用
* \{ \}           前置单个字符重新的正则表达式
无符号             连续
^ $               锚点
```

### 3.2.3 扩展正则表达式ERE

#### 3.2.3.1 匹配单个字符

与BRE基本一致，其他暂时不用考虑

#### 3.2.3.2 后向引用不存在

在ERE中无后向引用

#### 3.2.3.3 匹配单个表达式与多个正则表达式

* `?` 匹配0个或一个前置正则表达式
* `+` 匹配1个或多个前置正则表达式

#### 3.2.3.4 交替

* 方括号表达式易于表示`匹配于此字符，或其他字符，或...`,但不能指定匹配`这个序列，或是其他序列，或...`
* 交替运算符`|`(又名管道字符),指定匹配`这个序列，或是其他序列，或...`.例如，`read|write`,匹配于read或write。其优先级最低。
*

#### 3.2.3.5 分组

* `()`提供分组功能. `(why)+`匹配于一个或连续重复的多个why.

#### 3.2.3.6 停驻文本匹配

* `^`, `$`表示的意义和BRE里相同。
* 但是在ERE中,像`ab^cd` 与`ef$gh`这样的正则表达式还是`^`,`$`还是meta字符，只不过不能匹配到任何文本。而在BER中`ab^cd` ,`ef$gh`的` ^`, `$`已经不是meta字符，只代表其本身。

#### 3.2.3.7 ERE运算符的优先级

ERE运算符优先级，由高到低

```
运算符                           含义
[..] [= =] [: :]              用于字符对应的方括号符号
\metacharacter                转义的meta字符
[]                            方括号表达式
()                            分组
* + ? {}                      重复前置的正则表达式
无符号 (no symbol)             连续字符
^ $                           锚点
|                             交替

```

### 3.2.4 正则表达式的扩展

额外的GNU正则表达式运算符

```
运算符      含义
\w         匹配任何单词组成字符，等同于[[:alnum:]_]
\W         匹配任何非单词组成字符，等同于[^[:alnum:]_]
\<\>       匹配任何单词的起始与结尾
\b         匹配任何单词起始或结尾处所找到的空字符串
\B         匹配两个单词组成字符之间的空字符串
\'  \`     分别匹配GNU程序或emacs缓冲区的开始与结尾
```


### 3.2.5 程序与正则表达式

xxxxxxxxxxxxx

### 3.2.6 在文本文件里进行替换

* `sed`流编辑器程序执行文本替换

### 3.2.7 基本用法

![](./image/3-4.png)

1. 用替代文本替换匹配文本

```
sed 's/:.*//' /etc/passwd |  删除第一个冒号之后的东西
  sort -u                    排序列表并删除重复的部分

```

 * 在这里`/字符`是定界符，分隔正则表达式与替代文本。替代文本为空时，会删除匹配文本。



2. `/`是常用的定界符,但是任何可现实的字符都能作为定界符.


```
find /home/tolstoy -type d -print   | 寻找所有目录
  sed 's;/home/tolstoy/;/home/lt/;' | 修改名称;注意:这里使用分号作为定界符
   sed 's/^/mkdir /'                | 插入mkdir命令
     sh -x                            以shell跟踪模式执行

```


##### 3.2.7.1 替换细节

此时，暂不了解

### 3.2.8 sed的运作

* sed的工作方式相当直接,命令行上的每个文件名会依次打开与读取.如果没有文件，则使用标准输入，文件名`-`可用于表示标准输入。
* sed读取每个文件，依次读取一行。
* 每个读取的行，放到模式空间(内存的一个区域),所有操作完成的模式空间的内容被打印到标准输出。然后接着读取下一行。


#### 3.2.8.1 打印与否

* `-n`选项使sed不会在操作完成后打印模式空间的内容
* `-p`选项使sed在操作完成后打印模式空间的内容

### 3.2.9 匹配特定行

* sed可以限制一条命令应用到哪些行，只要在命令前置一个地址即可.


### 3.2.10 有多少文本会改动

用到时，具体了解

###  3.2.11 行v.s字符串

* grep,egrep,sed等,^与$分别表示行的开头与结尾
* awk, Perl，Python，^与$分别表示字符串的开头与结尾

## 3.3 字段处理

一条记录可理解为记录若干字段数据的集合。

### 3.3.1 文本文件惯例

* 在文本文件中，一行表示一条记录。
* 一行内用来分隔开不同的字段的两种惯例
  + 空格键或tab键
  + 用特定的定界符来分隔开不同字段，例如冒号.

### 3.3.2 使用cut选定字段

* cut命令是用来剪下文本文件里的数据

![](./image/3-5.png)


### 3.3.3 使用join连接字段

* join命令可以将多个文件结合在一起，每个文件里的每条记录都共享一个键值。

![](./image/3-6.png)

合并下列两个文件中的数据

```
$ cat sales
# 业务员数据
# 业务员   量
joe       100
jane      200
herman    150
chris     300


$ cat quotas
# 配额
# 业务员  配额
joe      100
jane     200
herman   150
chris    300

建立 merge-sales.sh

#! /bin/sh

# 删除注释并排序数据文件
sed '/^#/d' quotas | sort > quotas.sorted
sed '/^#/d' sales  | sort > sales.sorted

# 以第一个键值作结合，将结果产生至标准输出
join quotas.sorted  quotas.sorted

# 删除缓存文件
rm quotas.sorted quotas.sorted

***********
执行脚本后结果

chris   95  300
herman  80  150
jane    75  200
joe     50  100

```



### 3.3.4 使用awk重新编排字段


#### 3.3.4.1 模式与操作

* awk读取命令行上指定的各个文件，若无，则读取标准输入
* 一次读入一条记录(行)
* 然后针对每一行，应用程序所指定命令
* 基本架构: awk `pattern {action}`.若匹配`pattern`则执行`action`.

#### 3.3.4.2 字段

* awk读取输入记录，然后自动将各个记录切分为字段
* awk将每条记录内的字段数目，存储到内建变量NF

使用字段

```
awk '{ print $1}'           打印第1个字段 (未指定pattern)
awk '{ print $2, $5}'       打印第2个与第5个字段 (未指定pattern)
awk '{ print $2, $NF}'      打印第2个与最后一个字段 (未指定pattern)
awk 'NF > 0 { print $0}'    打印非空行(指定pattern与action)
awk 'NF> 0'                 同上 (未指定action，则默认为打印)
```

+ 特别注意 => 编号0:表示整条记录


#### 3.3.4.3 设置字段分隔字符

* awk的输入，输出分隔字符用法是分开的
 +  使用`-F`选项修改字段输入分隔字符. -F自动设置`FS`变量。
   `awk -F: '{print $1, $5}' /etc/passwd`,此时打印出的内容仍然是以空格作为分隔符
 +  使用`-v`选项修改字段输出分隔字符.但必须手动设置`OFS`变量。
    `awk -F: -v 'OFS=**' '{print $1, $5}' /etc/passwd`，此时打印出的内容以`**`作为分隔符

#### 3.3.4.4 设置字段分隔字符

awk的的打印会自动提示换行符

#### 3.3.4.5 起始与清除

了解一下

* BEGIN与END这两个特殊模式，提供了awk程序的起始和清除

```
BEGIN    {起始操作程序代码}
pattern1 {action1}
pattern2 {action2}
END      {清除操作程序代码}

$ awk 'BEGIN { FS= ":" ; OFS = "**" }

```